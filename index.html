<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Truck Route Maps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css">
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <style>
    :root { --bg:#0b1020; --card:#121a2f; --text:#e8ecf8; --muted:#a9b3c9; --danger:#ff6a6a; --ok:#4cd964; }
    * { box-sizing:border-box }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { display:grid; grid-template-rows:auto 1fr; height:100%; }
    header { display:flex; gap:1rem; align-items:center; padding:.75rem 1rem; border-bottom:1px solid #ffffff22; }
    header h1 { margin:0; font-size:1rem; color:var(--muted); font-weight:600; }
    #map { width:100%; height:100%; }
    .panel { position:absolute; top:76px; left:12px; z-index:500; background:var(--card); border:1px solid #ffffff22; border-radius:14px; padding:.8rem; width:min(460px, calc(100% - 24px)); }
    .row { display:flex; gap:.5rem; align-items:center; margin:.5rem 0; }
    .row > label { font-size:.85rem; color:var(--muted); min-width:106px; }
    input[type="text"], input[type="number"], select { flex:1; padding:.6rem .65rem; border-radius:10px; border:1px solid #ffffff22; background:#0e1530; color:var(--text); outline:none; }
    button { padding:.7rem 1rem; border-radius:10px; border:1px solid #ffffff33; background:#0f1a39; color:var(--text); cursor:pointer; }
    button.primary { background:#14306e; }
    button.ghost { background:transparent; }
    .mini { font-size:.85rem; color:var(--muted); }
    .chip { border:1px solid #ffffff33; border-radius:999px; padding:.35rem .6rem; cursor:pointer; display:inline-block; margin-right:.35rem; }
    .chip.active { background:#14306e; border-color:#3c64ff; }
    .legend { position:absolute; right:12px; top:76px; z-index:500; background:var(--card); border:1px solid #ffffff22; border-radius:14px; padding:.6rem .8rem; font-size:.85rem; }
    .dot { width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:.4rem; }
    .dot.bridge { background:#ff9f43; }
    .dot.low { background:#ff6a6a; }
    .dot.osr { background:#4cd964; }
    .notice { position:absolute; left:50%; transform:translateX(-50%); top:76px; z-index:500; background:#1b2d5e; border:1px solid #2e5fff55; color:#cfe0ff; border-radius:12px; padding:.5rem .8rem; display:none; }
    .bad{color:var(--danger);font-weight:600}.ok{color:var(--ok);font-weight:600}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Truck Route Maps</h1>
      <div class="mini">Click map twice to plot, or type addresses and press Plot.</div>
    </header>

    <div id="map"></div>

    <div class="panel" id="ui">
      <div class="row">
        <label>Mode</label>
        <div id="modeChips">
          <span class="chip active" data-mode="basic">Basic</span>
          <span class="chip" data-mode="premium">Premium</span>
        </div>
      </div>

      <div id="basicFields">
        <div class="row">
          <label>Truck type</label>
          <select id="truckType">
            <option value="">Select type…</option>
            <option value="9-axle">9-axle (2×2 + 2×3)</option>
            <option value="articulated-2">Artic (tractor + 2-axle)</option>
            <option value="articulated-3">Artic (tractor + 3-axle)</option>
            <option value="rigid">Rigid</option>
          </select>
        </div>
        <div class="row">
          <label>Total weight</label>
          <input id="grossWeight" type="number" min="0" step="0.1" placeholder="t — permitted or actual" />
        </div>
        <div class="mini">Persists for 24 h unless changed.</div>
      </div>

      <div id="premiumFields" style="display:none">
        <div class="row">
          <label>Truck unit</label>
          <select id="truckUnit"></select>
        </div>
        <div class="mini">Persists until you change it (per user).</div>
      </div>

      <hr style="border-color:#ffffff22; border-style:solid; border-width:1px 0 0; margin:.5rem 0 .75rem" />

      <div class="row"><label>Origin</label><input id="origin" type="text" placeholder="Address, suburb, place…"></div>
      <div class="row"><label>Destination</label><input id="destination" type="text" placeholder="Address, suburb, place…"></div>
      <div class="row">
        <label></label>
        <button class="primary" id="routeBtn">Plot route</button>
        <button class="ghost" id="resetBtn">Reset</button>
      </div>

      <div id="routeStatus" class="mini"></div>
      <div id="warnings" class="mini"></div>
    </div>

    <div class="legend">
      <div><span class="dot bridge"></span>Bridges (max weight)</div>
      <div><span class="dot low"></span>Low overbridges (height)</div>
      <div><span class="dot osr"></span>Oversize corridors</div>
    </div>

    <div id="selectionNotice" class="notice">Please choose your truck to continue.</div>
  </div>

  <script>
    /* ---------- Demo data ---------- */
    const DEMO_TRUCKS = [
      { id:'NJW08', label:'NJW08 (Artic 3-axle, 44t, 4.30m)', type:'articulated-3', gross_t:44, height_m:4.30 },
      { id:'KZX12', label:'KZX12 (9-axle, 53t, 4.25m)',       type:'9-axle',        gross_t:53, height_m:4.25 },
      { id:'TRG21', label:'TRG21 (Rigid, 25t, 4.10m)',        type:'rigid',         gross_t:25, height_m:4.10 },
    ];

    // Includes Mangere Bridge @ 50 t. Coordinates near centre of crossing.
    const DEMO_BRIDGES = [
      { name:'Bridge A', lat:-36.8485, lng:174.7633, max_t:44,  max_h:null },
      { name:'Bridge B', lat:-36.9200, lng:174.7750, max_t:30,  max_h:null },
      { name:'Low Overbridge C', lat:-36.8800, lng:174.7450, max_t:null, max_h:4.20 },
      { name:'Mangere Bridge', lat:-36.9658, lng:174.7830, max_t:50, max_h:null }
    ];

    const DEMO_OVERSIZE_CORRIDORS = [
      [ {lat:-36.85, lng:174.70}, {lat:-36.85, lng:174.90} ],
      [ {lat:-36.92, lng:174.70}, {lat:-36.80, lng:174.78} ],
    ];

    /* ---------- Persistence ---------- */
    const STORAGE_KEYS = { mode:'trm_mode', basic:'trm_basic_sel', premium:'trm_premium_sel' };
    const saveBasicSelection = x => localStorage.setItem(STORAGE_KEYS.basic, JSON.stringify({ ...x, ts:Date.now() }));
    const readBasicSelection = () => {
      const raw = localStorage.getItem(STORAGE_KEYS.basic); if(!raw) return null;
      try { const o = JSON.parse(raw); if(Date.now()-(o.ts||0) > 86400000) { localStorage.removeItem(STORAGE_KEYS.basic); return null; } return o; } catch { return null; }
    };
    const savePremiumSelection = unitId => localStorage.setItem(STORAGE_KEYS.premium, JSON.stringify({ unitId }));
    const readPremiumSelection = () => { const raw = localStorage.getItem(STORAGE_KEYS.premium); if(!raw) return null; try { return JSON.parse(raw); } catch { return null; } };
    const saveMode = m => localStorage.setItem(STORAGE_KEYS.mode, m);
    const readMode = () => localStorage.getItem(STORAGE_KEYS.mode) || 'basic';

    /* ---------- App state ---------- */
    let map, routeLine, originMarker, destMarker, forbiddenOverlay=null;
    let currentTruck = null, mode = 'basic';
    let bridgeLayer, lowLayer, osrLayer;
    let lastRouteCoords = [], clickedPoints = [];

    /* ---------- Helpers ---------- */
    const qs=(s,el=document)=>el.querySelector(s);
    const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
    const setChipsActive=(container,v)=> qsa('.chip',container).forEach(ch=>ch.classList.toggle('active', ch.dataset.mode===v));
    const updateSelectionNotice=()=>{ const ok = mode==='basic' ? !!readBasicSelection() : !!readPremiumSelection(); qs('#selectionNotice').style.display = ok ? 'none' : 'block'; };

    function setMode(newMode){
      mode = newMode; saveMode(mode); setChipsActive(qs('#modeChips'), mode);
      qs('#basicFields').style.display = mode==='basic' ? '' : 'none';
      qs('#premiumFields').style.display = mode==='premium' ? '' : 'none';
      loadCurrentTruckFromStorage(); refreshStatus(); updateSelectionNotice();
    }
    function loadCurrentTruckFromStorage(){
      if(mode==='basic'){
        const sel = readBasicSelection();
        currentTruck = sel ? { type:sel.truckType, gross_t:Number(sel.grossWeight||sel.gross_t||0) } : null;
        if(sel){ qs('#truckType').value = sel.truckType||''; qs('#grossWeight').value = sel.gross_t||sel.grossWeight||''; }
      } else {
        const sel = readPremiumSelection();
        if(sel){
          const t = DEMO_TRUCKS.find(x=>x.id===sel.unitId);
          currentTruck = t ? { type:t.type, gross_t:t.gross_t, height_m:t.height_m, unitId:t.id } : null;
          if(t) qs('#truckUnit').value = t.id;
        } else currentTruck = null;
      }
    }
    function refreshStatus(){
      const el = qs('#routeStatus');
      if(!currentTruck){ el.innerHTML = 'No truck selected.'; return; }
      const h = currentTruck.height_m ? `, H=${currentTruck.height_m.toFixed(2)}m` : '';
      el.innerHTML = mode==='basic'
        ? `Using <b>${currentTruck.type||'—'}</b>, gross <b>${currentTruck.gross_t||'—'}t</b> (expires 24 h).`
        : `Using unit <b>${currentTruck.unitId}</b> (<b>${currentTruck.type}</b>, ${currentTruck.gross_t}t${h}).`;
    }

    const haversine=(lat1,lon1,lat2,lon2)=>{ const R=6371000,toRad=d=>d*Math.PI/180;
      const dLat=toRad(lat2-lat1),dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a)); };

    function checkRouteAgainstLimits(){
      const out=[]; if(!currentTruck||lastRouteCoords.length===0) return out;
      const buf=50;
      for(const b of DEMO_BRIDGES){
        const near = lastRouteCoords.some(([lat,lng]) => haversine(lat,lng,b.lat,b.lng) <= buf);
        if(!near) continue;
        if(b.max_t!=null && currentTruck.gross_t && currentTruck.gross_t>b.max_t){
          out.push(`Weight: <span class="bad">${currentTruck.gross_t}t</span> exceeds <b>${b.name}</b> limit of <b>${b.max_t}t</b>.`);
        }
        if(b.max_h!=null && currentTruck.height_m && currentTruck.height_m>b.max_h){
          out.push(`Height: <span class="bad">${currentTruck.height_m.toFixed(2)}m</span> exceeds <b>${b.name}</b> clearance of <b>${b.max_h.toFixed(2)}m</b>.`);
        }
      }
      qs('#warnings').innerHTML = out.length ? out.map(w=>'• '+w).join('<br>') : '<span class="mini">No restriction warnings on demo data.</span>';
      return out;
    }

    /* ---------- Geocoding ---------- */
    async function geocode(text){
      if(!text) throw new Error('Empty address');
      const pick = (arr) => {
        if(!arr || !arr.length) return null;
        const a = arr[0];
        if (a.lat && a.lon) return { lat: parseFloat(a.lat), lng: parseFloat(a.lon) };
        if (a.geometry && Array.isArray(a.geometry.coordinates))
          return { lat: a.geometry.coordinates[1], lng: a.geometry.coordinates[0] };
        if (a.center && a.center.lat && a.center.lng) return { lat: a.center.lat, lng: a.center.lng };
        return null;
      };
      try {
        const u = new URL('https://nominatim.openstreetmap.org/search');
        u.searchParams.set('format', 'jsonv2');
        u.searchParams.set('q', text);
        u.searchParams.set('limit', '1');
        u.searchParams.set('countrycodes', 'nz');
        u.searchParams.set('accept-language', 'en');
        const r = await fetch(u.toString(), { mode:'cors' });
        if(!r.ok) throw new Error(`Nominatim HTTP ${r.status}`);
        const data = await r.json();
        const pt = pick(data);
        if (pt) return pt;
      } catch(e) {}
      try {
        const u = new URL('https://photon.komoot.io/api/');
        u.searchParams.set('q', text);
        u.searchParams.set('limit', '1');
        const r = await fetch(u.toString(), { mode:'cors' });
        if(!r.ok) throw new Error(`Photon HTTP ${r.status}`);
        const data = await r.json();
        const pt = pick(data.features || []);
        if (pt) return pt;
      } catch(e) {}
      throw new Error(`Couldn't geocode: "${text}"`);
    }

    /* ---------- OSRM routing ---------- */
    const OSRM = [
      'https://router.project-osrm.org/route/v1/driving/',
      'https://routing.openstreetmap.de/routed-car/route/v1/driving/'
    ];
    async function fetchRoute(o, d){
      const coords = `${o.lng},${o.lat};${d.lng},${d.lat}`;
      const qsuf = '?overview=full&alternatives=false&steps=false&annotations=distance&geometries=polyline';
      let lastErr;
      for (const base of OSRM) {
        try {
          const r = await fetch(base + coords + qsuf, { mode: 'cors' });
          if (!r.ok) throw new Error(`HTTP ${r.status} from ${base}`);
          const data = await r.json();
          if (data.code !== 'Ok' || !data.routes || !data.routes.length) throw new Error(`No route from ${base} (code=${data.code})`);
          return data.routes[0];
        } catch (e) { lastErr = e; }
      }
      const msg = lastErr ? (lastErr.message || String(lastErr)) : 'Unknown error';
      throw new Error(`Routing failed on all servers: ${msg}`);
    }
    async function fetchRouteMulti(points){
      const coordStr = points.map(p=>`${p.lng},${p.lat}`).join(';');
      const qsuf = '?overview=full&alternatives=false&steps=false&annotations=distance&geometries=polyline';
      let lastErr;
      for (const base of OSRM) {
        try {
          const r = await fetch(base + coordStr + qsuf, { mode:'cors' });
          if (!r.ok) throw new Error(`HTTP ${r.status} from ${base}`);
          const data = await r.json();
          if (data.code !== 'Ok' || !data.routes || !data.routes.length) throw new Error(`No multi-leg route (code=${data.code})`);
          return data.routes[0];
        } catch (e) { lastErr = e; }
      }
      const msg = lastErr ? (lastErr.message || String(lastErr)) : 'Unknown error';
      throw new Error(`Routing failed on all servers: ${msg}`);
    }

    function decodePolyline(str){
      let index=0, lat=0, lng=0, coordinates=[];
      while(index<str.length){
        let b, shift=0, result=0;
        do { b=str.charCodeAt(index++)-63; result|=(b&0x1f)<<shift; shift+=5; } while(b>=0x20);
        const deltaLat = (result&1)?~(result>>1):(result>>1);
        shift=0; result=0;
        do { b=str.charCodeAt(index++)-63; result|=(b&0x1f)<<shift; shift+=5; } while(b>=0x20);
        const deltaLng = (result&1)?~(result>>1):(result>>1);
        lat+=deltaLat; lng+=deltaLng;
        coordinates.push([lat/1e5, lng/1e5]);
      }
      return coordinates;
    }

    /* ---------- Mangere Bridge detour logic ---------- */
    const MANGERE = DEMO_BRIDGES.find(b => b.name === 'Mangere Bridge');

    // BIGGER buffers to guarantee detection on that crossing
    function routePassesBridge(lineCoords, bridge, bufferM=600){
      return lineCoords.some(([lat,lng]) => haversine(lat,lng, bridge.lat, bridge.lng) <= bufferM);
    }
    function extractSegmentNearBridge(lineCoords, bridge, bufferM=800){
      const idxs = lineCoords
        .map(([lat,lng],i)=> ({i, d:haversine(lat,lng,bridge.lat,bridge.lng)}))
        .filter(o=>o.d<=bufferM)
        .map(o=>o.i);
      if (idxs.length===0) return [];
      const iMin = Math.max(0, Math.min(...idxs)-8);
      const iMax = Math.min(lineCoords.length-1, Math.max(...idxs)+8);
      return lineCoords.slice(iMin, iMax+1);
    }

    /* ---------- Actions ---------- */
    async function routePlot(){
      const originTxt = qs('#origin').value.trim();
      const destTxt   = qs('#destination').value.trim();
      if(!originTxt || !destTxt){ alert('Enter both origin and destination.'); return; }
      if(!currentTruck){ alert('Please select your truck first.'); return; }
      qs('#routeStatus').textContent='Finding route…';
      try {
        const [o, d] = await Promise.all([geocode(originTxt), geocode(destTxt)]);
        await drawRoute(o, d);
      } catch(e){
        qs('#routeStatus').innerHTML = `<span class="bad">Could not find route: ${e.message}</span>`;
        console.error(e);
      }
    }

    async function drawRoute(o, d){
      if(routeLine){ map.removeLayer(routeLine); routeLine=null; }
      if(forbiddenOverlay){ map.removeLayer(forbiddenOverlay); forbiddenOverlay=null; }
      if(originMarker) map.removeLayer(originMarker);
      if(destMarker) map.removeLayer(destMarker);

      originMarker = L.marker([o.lat,o.lng]).addTo(map).bindPopup('Origin');
      destMarker   = L.marker([d.lat,d.lng]).addTo(map).bindPopup('Destination');

      try {
        // 1) Get naive fastest route (usually across Mangere for CBD→AKL)
        const r = await fetchRoute(o,d);
        const baseLine = decodePolyline(r.geometry);

        const overweight = currentTruck && currentTruck.gross_t && MANGERE && (currentTruck.gross_t > MANGERE.max_t);
        const crosses = MANGERE ? routePassesBridge(baseLine, MANGERE) : false;

        if (overweight) {
          // Always compute a detour for > 50 t (guarantee re-route)
          // Red "would-have" overlay if our base route crossed Mangere
          if (crosses) {
            const seg = extractSegmentNearBridge(baseLine, MANGERE);
            if (seg.length>1) forbiddenOverlay = L.polyline(seg, { weight:10, opacity:0.65, color:'#ff6a6a' }).addTo(map);
          }

          // Shape via east to avoid the harbour crossing
          const viaA = { lat:-36.9140, lng:174.8320 }; // Ellerslie/Penrose
          const viaB = { lat:-36.9810, lng:174.8750 }; // East Manukau / Papatoetoe
          const rd = await fetchRouteMulti([o, viaA, viaB, d]);
          const detour = decodePolyline(rd.geometry);
          lastRouteCoords = detour;

          routeLine = L.polyline(detour, { weight:6, opacity:0.9 }).addTo(map);
          map.fitBounds(routeLine.getBounds(), { padding:[30,30] });

          const km = (rd.distance/1000).toFixed(1);
          const min = (rd.duration/60).toFixed(0);
          qs('#routeStatus').innerHTML = `<span class="mini">Detoured to avoid <b>${MANGERE.name}</b> (limit ${MANGERE.max_t}t). Route: <span class="ok">${km} km</span>, ${min} min</span>`;
          qs('#warnings').innerHTML = `• Weight: <span class="bad">${currentTruck.gross_t}t</span> exceeds <b>${MANGERE.name}</b> limit of <b>${MANGERE.max_t}t</b>. Detour applied.`;
        } else {
          // ≤ 50 t: use normal fastest
          lastRouteCoords = baseLine;
          routeLine = L.polyline(baseLine, { weight:6, opacity:0.9 }).addTo(map);
          map.fitBounds(routeLine.getBounds(), { padding:[30,30] });
          const km = (r.distance/1000).toFixed(1);
          const min = (r.duration/60).toFixed(0);
          qs('#routeStatus').innerHTML = `<span class="mini">Route: <span class="ok">${km} km</span>, ${min} min</span>`;
          checkRouteAgainstLimits();
        }
      } catch(e){
        qs('#routeStatus').innerHTML = `<span class="bad">Routing failed: ${e.message}</span>`;
        console.error(e);
      }
    }

    function resetAll(){
      qs('#origin').value=''; qs('#destination').value='';
      if(routeLine){ map.removeLayer(routeLine); routeLine=null; }
      if(forbiddenOverlay){ map.removeLayer(forbiddenOverlay); forbiddenOverlay=null; }
      if(originMarker){ map.removeLayer(originMarker); originMarker=null; }
      if(destMarker){ map.removeLayer(destMarker); destMarker=null; }
      lastRouteCoords=[]; clickedPoints=[];
      qs('#warnings').innerHTML=''; qs('#routeStatus').innerHTML='';
    }

    /* ---------- Init ---------- */
    function init(){
      map = L.map('map', { zoomControl:true }).setView([-36.8485, 174.7633], 11);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19, attribution:'&copy; OpenStreetMap contributors' }).addTo(map);

      // Test route button
      const testBtn = document.createElement('button');
      testBtn.textContent = 'Test route (CBD → AKL Airport)';
      testBtn.className = 'ghost';
      testBtn.onclick = () => { qs('#origin').value='Auckland CBD'; qs('#destination').value='Auckland Airport'; routePlot(); };
      const row = document.createElement('div'); row.className='row'; row.innerHTML='<label></label>'; row.appendChild(testBtn); qs('#ui').appendChild(row);

      // Click-to-plot
      map.on('click', async e=>{
        clickedPoints.push({ lat:e.latlng.lat, lng:e.latlng.lng });
        if(clickedPoints.length===1){
          qs('#routeStatus').textContent = 'Origin set by click. Click again to set destination.';
        } else if(clickedPoints.length===2){
          const [o,d]=clickedPoints; clickedPoints=[];
          await drawRoute(o,d);
        }
      });

      // Mode toggles
      qsa('#modeChips .chip').forEach(ch => ch.onclick=()=>setMode(ch.dataset.mode));

      // Premium list
      const unitSelect=qs('#truckUnit');
      unitSelect.innerHTML = DEMO_TRUCKS.map(t=>`<option value="${t.id}">${t.label}</option>`).join('');
      unitSelect.onchange = e => { savePremiumSelection(e.target.value); loadCurrentTruckFromStorage(); refreshStatus(); updateSelectionNotice(); };

      // Basic selectors
      const onBasicChange = () => {
        const v = qs('#truckType').value; const w = Number(qs('#grossWeight').value||0);
        if(v && w>0){ saveBasicSelection({truckType:v, gross_t:w}); loadCurrentTruckFromStorage(); refreshStatus(); updateSelectionNotice(); }
      };
      qs('#truckType').onchange = onBasicChange; qs('#grossWeight').onchange = onBasicChange;

      // Buttons
      qs('#routeBtn').onclick = routePlot; qs('#resetBtn').onclick = resetAll;

      // Enter submits
      ['origin','destination'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); routePlot(); } });
      });

      // Static overlays
      renderStaticLayers();

      // Restore mode + selection
      setMode(readMode()); loadCurrentTruckFromStorage();

      // If nothing selected yet, auto-fill 53 t so Test shows the detour
      if(!readBasicSelection()){
        qs('#truckType').value = '9-axle';
        qs('#grossWeight').value = 53;
        saveBasicSelection({truckType:'9-axle', gross_t:53});
        loadCurrentTruckFromStorage();
      }
      refreshStatus(); updateSelectionNotice();

      window.addEventListener('error', ev => { qs('#routeStatus').innerHTML = `<span class="bad">Script error: ${ev.message}</span>`; });
    }

    function renderStaticLayers(){
      const bridgeIcon = L.divIcon({ html:`<div style="background:#ff9f43;width:12px;height:12px;border-radius:3px;border:1px solid #0003"></div>`, className:'', iconSize:[12,12] });
      bridgeLayer = L.layerGroup();
      for(const b of DEMO_BRIDGES){
        if(b.max_t!=null){
          L.marker([b.lat,b.lng],{icon:bridgeIcon}).bindPopup(`<b>${b.name}</b><br>Max weight: ${b.max_t} t`).addTo(bridgeLayer);
        }
      }
      const lowIcon = L.divIcon({ html:`<div style="background:#ff6a6a;width:12px;height:12px;border-radius:3px;border:1px solid #0003"></div>`, className:'', iconSize:[12,12] });
      lowLayer = L.layerGroup();
      for(const b of DEMO_BRIDGES){
        if(b.max_h!=null){
          L.marker([b.lat,b.lng],{icon:lowIcon}).bindPopup(`<b>${b.name}</b><br>Max height: ${b.max_h.toFixed(2)} m`).addTo(lowLayer);
        }
      }
      osrLayer = L.layerGroup();
      for(const path of DEMO_OVERSIZE_CORRIDORS){
        L.polyline(path.map(p=>[p.lat,p.lng]), { color:'#4cd964', weight:4, opacity:0.85 }).addTo(osrLayer);
      }
      bridgeLayer.addTo(map); lowLayer.addTo(map); osrLayer.addTo(map);
    }

    // Boot
    window.onload = init;
  </script>
</body>
</html>
